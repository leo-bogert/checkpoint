#!/bin/bash
set -o pipefail	# this is absolutely critical: make pipes exit with failure if any of the involved commands fails. the default is exit status of the last command.
set -o nounset	# exit with error upon access of unset variable

################################################################################################################################
# global variables
################################################################################################################################
declare CHECKPATH								# directory to generate checkpoint of
declare OUTPUTDIR								# directory to place checkpoint in
declare -A OUTPUTFILES							# files which will reside in the output directory
OUTPUTFILES[CHECKPOINT]=""						# the checkpoint itself
OUTPUTFILES[CHECKPOINT_OLDFORMAT_DATES]=""		# an oldformat date checkpoint - for testing the script against the old reference implementation
OUTPUTFILES[CHECKPOINT_OLDFORMAT_SHA256]=""		# an oldformat sha256 checkpoint - for testing the script against the old reference implementation
OUTPUTFILES[LOG]=""								# the log of stderr during computation. i

# the following associative arrays contain the output files.
# key=path of file, value=checkpoint line as it should appear in the output
declare -A OUTPUT_LINES_BY_PATH_WITHOUT_PREFIX	# output file OUTPUTFILES[CHECKPOINT]. we CANNOT store the \0 character in bash variables so we don't include the "filepath\0" prefix, we echo it to the outputfile instead.
declare -A OUTPUT_LINES_BY_PATH_DATE_ONLY		# output file OUTPUTFILES[CHECKPOINT_OLDFORMAT_DATES]
declare -A OUTPUT_LINES_BY_PATH_SHA256_ONLY		# output file OUTPUTFILES[CHECKPOINT_OLDFORMAT_SHA256]

declare ABORTED="false"							# will be set to "true" by the SIGHUP/SIGINT/SIGTERM trap to gracefully abort computation so resuming actually works
################################################################################################################################

log() {
	echo "$@" >&2
}

fail() {
	log "$@"
	exit 1
}

generate_files_and_directories() {
	(
		mkdir -p "$OUTPUTDIR" &&
		( [ "$(id -u -n)" != root ] || chown root:root "$OUTPUTDIR" ) &&
		chmod 700 "$OUTPUTDIR" &&
		touch "${OUTPUTFILES[@]}" &&
		chmod 600 "${OUTPUTFILES[@]}"
	) || fail "Output dir generation failed!"
}

redirect_stderr_to_log() {
	exec 2>> "${OUTPUTFILES[LOG]}" || fail "Redirecting stderr to ${OUTPUTFILES[LOG]} failed!"
}

trap_signals() {
	trap "interrupt_compute" HUP INT TERM  || fail "trap failed!"
}

set_ioniceness() {
	ionice -c 3 -p $$ || fail "ionice failed!"
}

load_existing_checkpoint() {
	log "Loading existing checkpoint data to resume from it ..."

	local filepath
	local line_without_filepath_prefix
	local split_line
	local -i count=0
	local -i ignored_count=0
	
	[ ! -s "${OUTPUTFILES[CHECKPOINT]}" ] && { log "No existing checkpoint found, creating a fresh one..." ; return 0 ; }
	
	while true ; do
		# The EOF marker is a line which contains one of the entries in the "case" statement below followed by \0 and nothing else.
		# So we should always be able to read something which is terminated by \0
		{ IFS= read -r -d $'\0' filepath ; } || fail "End of file marker not found - Input file is incomplete!"
		
		# Each line is composed of the filename followed by \0 followed by the checkpoint data followed by \n
		# If the checkpoint data cannot be read, we have reached the end of file. 
		# The "filename" should be the EOF marker then. So we check whether it is.
		if ! IFS= read -r line_without_filepath_prefix ; then
			case "$filepath" in
				$'This checkpoint is complete.\n')
					fail "Checkpoint is complete already, nothing to do. Exiting." ;;
				$'This checkpoint is INCOMPLETE but can be resumed.\n') 
					break ;; # The file was complete so we can finish the loop.
				*)
 					fail "End of file marker not found - Input file is incomplete!" ;;
			esac
		fi
		
		[[ "$line_without_filepath_prefix" = *'(sha256sum failed!)'* ]] && { let ignored_count++ ; continue ; }
		[[ "$line_without_filepath_prefix" = *'(stat failed!)'* ]] && { let ignored_count++ ; continue ; }
		
		OUTPUT_LINES_BY_PATH_WITHOUT_PREFIX["$filepath"]="$line_without_filepath_prefix"
		
		# new data is complete.
		# we don't read the old format files. instead we compute them from the new format data.
		# - they could never be parsed correctly because they delimit the filename with "\n" which is a valid character in linux filenames.
		
		# Split the line by \t
		IFS=$'\t' read -r -a split_line <<< "$line_without_filepath_prefix"
		
		local sha="${split_line[0]}"
		local times="${split_line[@]:1}"
		
		[ "$sha" != "(directory)" ] && OUTPUT_LINES_BY_PATH_SHA256_ONLY["$filepath"]="$sha *$filepath"
		OUTPUT_LINES_BY_PATH_DATE_ONLY["$filepath"]="$filepath"$'\t'"$times"$'\t'
		
		let count++
	done < "${OUTPUTFILES[CHECKPOINT]}"
	
	log "Loaded $count existing checkpoint datasets, ignored $ignored_count existing datasets where sha256sum or stat had failed previously."
}

interrupt_compute() {
	ABORTED=true	
}

compute() {
	log "Computing checkpoint ..."

	# We run find inside the target directory so the filenames in the output are relative
	cd "$CHECKPATH" || fail "cd to $CHECKPATH failed!"
	
	local file
	local -i computed=0
	local -i failed=0
	local -i skipped=0
	
	# Source of this magic: http://mywiki.wooledge.org/BashFAQ/020
	# IFS= to prevent trimming the string, ie. removing leading/trailing whitespace
	# -r = Backslash does not act as an escape character
	# -d = Sets the delimiter to null
	while IFS= read -r -d $'\0' file; do
		[ "$ABORTED" != "false" ] && { log "Aborting computation due to signal!" ; break ; }
		[ ${#OUTPUT_LINES_BY_PATH_WITHOUT_PREFIX["$file"]} -ne 0 ] && { let skipped++ ; continue ; }
		
		local sha=""
		local stat=""
		
		if [ -f "$file" ] ; then
			shaoutput="$(sha256sum --binary "$file")" && read -r -a sha_array <<< "$shaoutput" || { sha_array[0]="(sha256sum failed!)" ; let failed++ ; }
			sha="${sha_array[0]}"
		elif [ -d "$file" ] ; then
			sha="(directory)"
		elif [ ! -e "$file" ]; then
			log "File deleted during processing: $file"
			continue
		else
			fail "Unexpected type of file: $file"
		fi
		
		stat="$(stat --printf "Birth: %w\tAccess: %x\tModify: %y\tChange: %z" "$file")" || { stat="(stat failed!)" ; let failed++ ; }
		
		# new format
		OUTPUT_LINES_BY_PATH_WITHOUT_PREFIX["$file"]=$'\t'"$sha"$'\t'"$stat"
		
		# old format of date listing
		OUTPUT_LINES_BY_PATH_DATE_ONLY["$file"]="$file"$'\t'"$stat"
		# old format of sha listing
		[ -f "$file" ] && OUTPUT_LINES_BY_PATH_SHA256_ONLY["$file"]="$sha *$file"

		let computed++
	done < <(find . -mount \( -type f -o -type d \) -print0)
	
	log "Computing finished. Computed $computed entries successfully. $failed computations failed. Skipped $skipped of ${#OUTPUT_LINES_BY_PATH_WITHOUT_PREFIX[@]} files due to incremental computation."
}

truncate_output() {
	> "${OUTPUTFILES[CHECKPOINT]}"
	> "${OUTPUTFILES[CHECKPOINT_OLDFORMAT_DATES]}"
	> "${OUTPUTFILES[CHECKPOINT_OLDFORMAT_SHA256]}"
}

write_eof_marker_to_output() {
	for outputfile in "${OUTPUTFILES[@]}" ; do
 		{ [ "$ABORTED" = "false" ] && echo -n -e "This checkpoint is complete.\n\0" || echo -n -e "This checkpoint is INCOMPLETE but can be resumed.\n\0" ; } >> "$outputfile"
	done
}

write_output() {
	log "Writing checkpoint to disk ..."

	truncate_output

	local count
	local file
	while IFS= read -r -d $'\0' file ; do
		{
			echo -n "$file"
			echo -n -e "\0"
			echo "${OUTPUT_LINES_BY_PATH_WITHOUT_PREFIX[$file]}" ;	# "${array[$key]}" is sufficient, quoting of the key not needed
		} >> "${OUTPUTFILES[CHECKPOINT]}"
		
		# old format with date only
		echo "${OUTPUT_LINES_BY_PATH_DATE_ONLY[$file]}" >> "${OUTPUTFILES[CHECKPOINT_OLDFORMAT_DATES]}"
		
		# old format with sha only
		[ ${#OUTPUT_LINES_BY_PATH_SHA256_ONLY["$file"]} -ne 0 ] && echo "${OUTPUT_LINES_BY_PATH_SHA256_ONLY[$file]}" >> "${OUTPUTFILES[CHECKPOINT_OLDFORMAT_SHA256]}"

		let count++
	done < <(
			for filepath in "${!OUTPUT_LINES_BY_PATH_WITHOUT_PREFIX[@]}" ; do
				echo -n "$filepath"
				echo -n -e "\0"
			done | sort --stable --zero-terminated
		)

	write_eof_marker_to_output

	log "Finished writing checkpoint to disk. Wrote $count entries."
}


main() {
	set -o errexit # exit shell upon any error
		[ $# -eq 2 ] || fail "Syntax: checkpoint <dir to generate checkpoint for> <output dir of checkpoint files>"

		local checkpath_tmp="$1"
		local outputdir_tmp="$2"
		
		# strip trailing slash
		checkpath_tmp="${checkpath_tmp%/}"
		outputdir_tmp="${outputdir_tmp%/}"
		# make the directories absolute
		[[ "$checkpath_tmp" != /* ]] && checkpath_tmp="$(pwd)"/"$checkpath_tmp"
		[[ "$outputdir_tmp" != /* ]] && outputdir_tmp="$(pwd)"/"$outputdir_tmp"
		
		readonly CHECKPATH="$checkpath_tmp"
		[ -d "$CHECKPATH" ] || fail "Dir to generate checkpoint for does not exist or is no directory: $CHECKPATH"
		
		readonly OUTPUTDIR="$outputdir_tmp"
		OUTPUTFILES[CHECKPOINT]="$OUTPUTDIR/checkpoint.txt"
		OUTPUTFILES[CHECKPOINT_OLDFORMAT_DATES]="$OUTPUTDIR/filedates.txt"
		OUTPUTFILES[CHECKPOINT_OLDFORMAT_SHA256]="$OUTPUTDIR/files.sha256"
		OUTPUTFILES[LOG]="$OUTPUTDIR/errors.log"	
		readonly OUTPUTFILES
		
	set +o errexit # don't exit upon error. this is necessary for compute() especially because some files might be deleted during our huge execution time
		
	generate_files_and_directories # generate output dir before writing to logfile since it resides in it
	redirect_stderr_to_log
	trap_signals # trap signals after starting to log so we can log them
	set_ioniceness
	load_existing_checkpoint
	compute
	# TODO: remove_inexistant_files
	write_output
}

main "$@"
